<head>
    <style>
        canvas {
            width: 300px;
            height: 300px;
            border: 2px solid #efefef;
        }

        img {
            width: 40px;
            height: 40px;
        }
    </style>
</head>
<body>

<img id='texture' src="texture.png"/> <br/>
<canvas id="webgl" width="300px" height="300px"></canvas>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
  attribute vec3 a_pos;
  attribute vec4 a_color;
  attribute vec2 a_uv;

  uniform mat4 u_proj;
  uniform mat4 u_model;
  uniform float u_time_offset;

  varying vec4 v_color;
  varying float v_time_offset;
  varying vec2 v_uv;

  void main(void) {
    gl_Position = u_proj * u_model * vec4(a_pos, 1.0);
    v_color = a_color;
    v_time_offset = u_time_offset;
    v_uv = a_uv;
  }
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;
  uniform sampler2D u_sampler;
  varying vec4 v_color;
  varying float v_time_offset;
  varying vec2 v_uv;

  void main() {
    float r = sin(v_time_offset + gl_FragCoord[0] / 100.0);
    float g = sin(v_time_offset + gl_FragCoord[1] / 100.0);
    float b = 1.0;
    vec4 t = texture2D(u_sampler, vec2(v_uv.s, v_uv.t));
    r = r * 0.2 + t[0] * 0.8;
    g = g * 0.2 + t[1] * 0.8;
    b = b * 0.2 + t[2] * 0.8;
    gl_FragColor = vec4(r,g,b,1.0);
  }
</script>

<script src="libs/requirejs/require.js"></script>
<script>
    require([
        'build/context',
        'build/draw/scene',
        'build/utils/buffer',
        'build/shader',
        'build/geom/prefab/cube',
        'build/program',
    ], function (c, scene, buffer, shader, cube, prog) {
        var glc;
        try {
            // Load webgl context
            try {
                glc = c.context('webgl');
                glc.viewport();
            }
            catch (e) {
                console.log('No webgl');
                console.log(e);
                return;
            }

            // Setup~
            var scene = new scene.Scene(glc);

            // Create a renderer to use
            var renderer = scene.renderer();

            var time_offset = buffer.factory(1);
            renderer.program = function (glc) {
                var gl = glc.gl;

                var vertexShader = shader.fromScript("2d-vertex-shader");
                var fragmentShader = shader.fromScript("2d-fragment-shader");
                var program = new prog.Program(glc, {vertex: vertexShader, fragment: fragmentShader});

                // Bind shader attributes
                program.bind('a_pos', prog.BufferType.VERTEX_FLOAT3);
                program.bind('a_color', prog.BufferType.VERTEX_FLOAT4);
                program.bind('a_uv', prog.BufferType.VERTEX_FLOAT2);
                program.bind('u_proj', prog.BufferType.UNIFORM_MAT4);
                program.bind('u_model', prog.BufferType.UNIFORM_MAT4);
                program.bind('u_sampler', prog.BufferType.UNIFORM_SAMPLER);

                // Timer is not generated from the geom source
                program.bind('u_time_offset', prog.BufferType.UNIFORM_FLOAT);
                program.buffer('u_time_offset', time_offset);
                time_offset.data[0] = 0.0;

                // Turn depth testing on
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LESS);

                return program;
            };

            // Set camera
            scene.camera.position(0, 0, -5);

            // Set background
            scene.background  = [0.0, 0.0, 0.0, 1.0];

            // Add some geometry
            var texture = document.getElementById('texture');
            var cube = new cube.Cube({
                a_vertex: 'a_pos',
                a_uv: 'a_uv',
                a_color: 'a_color',
                u_sampler: 'u_sampler',
                texture: texture,
                size: [1.0, 1.0, 1.0],
                position: [0.0, 0.0, 0.0]
            });

            renderer.add(cube.compile(glc));
            glc.check();

            // Updater
            var timer = 0;
            renderer.update = function (step) {
                timer += step;
                time_offset.data[0] = timer * 0.001;
                renderer.camera.modelview.unity().rotateX(timer * 0.001).rotateZ(timer * 0.001).translate(0, 0, -4);
            };
            glc.check();

            // Render each frame
            glc.run(function (step) { scene.render(step); });
        }
        catch (e) {
            console.log(e);
        }
    });
</script>
</body>
